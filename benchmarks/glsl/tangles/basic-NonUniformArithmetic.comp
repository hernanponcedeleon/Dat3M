//; @Input: %_ = {{1, 2, 3, 4, 5, 6}}
//; @Input: %__0 = {{0, 0, 0, 0, 0, 0}}
//; @Input: %__1 = {{0, 0, 0, 0, 0, 0}}
//; @Input: %__2 = {{0, 0, 0, 0, 0, 0}}
//; @Input: %__3 = {{0, 0, 0, 0, 0, 0}}
//; @Input: %__4 = {{0, 0, 0, 0, 0, 0}}
//; @Input: %__5 = {{0, 0, 0, 0, 0, 0}}
//; @Input: %__6 = {{0, 0, 0, 0, 0, 0}}
//; @Output: forall (%__0[0][0] == 6 and %__0[0][1] == 6 and %__0[0][2] == 6 and %__0[0][3] == 15 and %__0[0][4] == 15 and %__0[0][5] == 15)
//; @Output: forall (%__1[0][0] == 6 and %__1[0][1] == 6 and %__1[0][2] == 6 and %__1[0][3] == 120 and %__1[0][4] == 120 and %__1[0][5] == 120)
//; @Output: forall (%__2[0][0] == 0 and %__2[0][1] == 0 and %__2[0][2] == 0 and %__2[0][3] == 4 and %__2[0][4] == 4 and %__2[0][5] == 4)
//; @Output: forall (%__3[0][0] == 3 and %__3[0][1] == 3 and %__3[0][2] == 3 and %__3[0][3] == 7 and %__3[0][4] == 7 and %__3[0][5] == 7)
//; @Output: forall (%__4[0][0] == 0 and %__4[0][1] == 0 and %__4[0][2] == 0 and %__4[0][3] == 7 and %__4[0][4] == 7 and %__4[0][5] == 7)
//; @Output: forall (%__5[0][0] == 0 and %__5[0][1] == 1 and %__5[0][2] == 3 and %__5[0][3] == 0 and %__5[0][4] == 4 and %__5[0][5] == 9)
//; @Output: forall (%__6[0][0] == 1 and %__6[0][1] == 3 and %__6[0][2] == 6 and %__6[0][3] == 4 and %__6[0][4] == 9 and %__6[0][5] == 15)
//; @Config: 3, 2, 1

#version 460
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_memory_scope_semantics : enable

#define scope_subgroup 3
#define storage_sem_buffer 64 // Might need SubgroupMemory (128) for subgroup barriers/operations
#define sem_release 4
#define sem_acquire 2

layout(set = 0, binding = 0) buffer Buf { uint buf[]; };
layout(set = 0, binding = 2) buffer IAdd { uint iadd[]; };
layout(set = 0, binding = 2) buffer IMul { uint imul[]; };
layout(set = 0, binding = 2) buffer IAnd { uint iand[]; };
layout(set = 0, binding = 2) buffer IOr { uint ior[]; };
layout(set = 0, binding = 2) buffer IXor { uint ixor[]; };
layout(set = 0, binding = 2) buffer IExScan { uint exscan[]; };
layout(set = 0, binding = 2) buffer IInScan { uint inscan[]; };

void main() {
    uint subgroup_id = gl_SubgroupID;
    uint subgroup_size = gl_SubgroupSize;
    uint subgroup_local_id = gl_SubgroupInvocationID;
    uint num_workgroup = gl_NumWorkGroups.x;
    uint workgroup_size = gl_WorkGroupSize.x;
    uint workgroup_id = gl_WorkGroupID.x;
    uint workgroup_base = workgroup_size * workgroup_id;
    uint subgroup_base = subgroup_id * subgroup_size;
    uint virtual_gid = workgroup_base + subgroup_base + subgroup_local_id;
    uint next_virtual_gid = workgroup_base + subgroup_base + ((subgroup_local_id + 1) % subgroup_size);

    uint read = atomicLoad(buf[virtual_gid], scope_subgroup, storage_sem_buffer, sem_acquire);
    
    uint a = subgroupAdd(read);
    uint b = subgroupMul(read);
    uint c = subgroupAnd(read);
    uint d = subgroupOr(read);
    uint e = subgroupXor(read);
    uint f = subgroupExclusiveAdd(read);
    uint g = subgroupInclusiveAdd(read);

    atomicStore(iadd[virtual_gid], a, scope_subgroup, storage_sem_buffer, sem_release);
    atomicStore(imul[virtual_gid], b, scope_subgroup, storage_sem_buffer, sem_release);
    atomicStore(iand[virtual_gid], c, scope_subgroup, storage_sem_buffer, sem_release);
    atomicStore(ior[virtual_gid], d, scope_subgroup, storage_sem_buffer, sem_release);
    atomicStore(ixor[virtual_gid], e, scope_subgroup, storage_sem_buffer, sem_release);
    atomicStore(exscan[virtual_gid], f, scope_subgroup, storage_sem_buffer, sem_release);
    atomicStore(inscan[virtual_gid], g, scope_subgroup, storage_sem_buffer, sem_release);
}