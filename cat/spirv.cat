SPIRV

(* Tags from spirv.als *)
// NONPRIV, PRIV : non-private (participates in inter-thread ordering) vs private
// SCOPESG, SCOPEWG, SCOPEQF, SCOPEDEV: subgroup/workgroup/queuefamily/device scopes

(* Terms from spirv.als no need for implementation *)
// stor : set to relation, (s,s) for all s in E, lift a set to a relation (the [_] operator in Herd)
// imm-r = r - r;r      ????? or r - (r;r+)
// twoplus-r = r;r      ????? or (r;r+)
// rai-r = r | r^-1
// sthd = int
// immpo = po - po;po
// rc[r] = r?

// ssg, swg, sqf = sr@ subgroup, workgroup, queuefamily
// ssw = sdv, specifies that the first thread system-synchronizes-with the second thread.
//       use same-device as replacement for system-synchronizes-with

// inscope = sr

// pgmsloc = loc
// pgmsref == direct-alias
// sloc = loc
// sref = vloc
// scbarinst = sync_barrier: relates pairs of control barriers, same control barrier dynamic instance

//???????????
// chains = [_] or _*_ ?
// asmo = strong operation(with scope) ?????

(*******************)
(*  Auxiliaries *)
(*******************)
let mutordatom = [ATOM]; ((loc & vloc & sr) \ id); [ATOM] // mutually ordered atomics (same loc, inscope)
let avvisinc = (((SC0 | SC1) * (AVDEVICE | VISDEVICE)) | ((AVDEVICE | VISDEVICE) * (SC0 | SC1)) |
               (SC0 * ((SEMAV | SEMVIS) & SEMSC0)) | (((SEMAV | SEMVIS) & SEMSC0) * SC0) |
               (SC1 * ((SEMAV | SEMVIS) & SEMSC0)) | (((SEMAV | SEMVIS) & SEMSC0) * SC1)) \ id |
               ([AV | VIS]; (vloc & loc)) | ((vloc & loc); [AV | VIS])
let posctosem = [SC0]; po; [SEMSC0] | [SC1]; po; [SEMSC1]
let posemtosc = [SEMSC0]; po; [SC0] | [SEMSC1]; po; [SC1]

(*******************)
let asmo = [ATOM & W]; mutordatom; [ATOM & W] // should be rai[asmo] = ((A&W) -> (A&W)) & mutordatom
let rs = [REL & ATOM]; ((asmo \ (asmo; asmo)); [R & W])*
let hypors = [W & ATOM]; ((asmo \ (asmo; asmo)); [R & W])*
(*******************)

// synchronizes-with is similar to C++, with an additional case for fence->cbar->cbar->fence
let sw = sr & (
    ([REL & ATOM]; rs; (rf & mutordatom); [ACQ & ATOM]) |                                               // atomic->atomic
    ([REL & F]; posemtosc; [ATOM & W]; hypors; (rf & mutordatom); [ACQ & ATOM]) |                       // fence->atomic
    ([REL & ATOM]; rs; (rf & mutordatom); [ATOM & R]; posctosem; [ACQ & F]) |                           // atomic->fence
    ([REL & F]; posemtosc; [ATOM & W]; hypors; (rf & mutordatom); [ATOM & R]; posctosem; [ACQ & F]) |   // fence->fence
    [REL & F]; po?; [CBAR]; (sync_barrier & sr \ id); [CBAR]; po?; [ACQ & F]                               // fence->cbar->cbar->fence,
    // (stor[CBAR]) terms are redundant because scbarinst is an equivalence relation on scbarinst, but they make the sequence of instructions more clear.
)

let ithbsemsc0 = ( sdv |
                   ([SEMSC0]; sw; [SEMSC0]) |
                   ([SC0 | SEMSC0]; po; [REL & SEMSC0]) |
                   ([ACQ & SEMSC0]; po; [SC0 | SEMSC0])
                 )*
let ithbsemsc1 = ( sdv |
                   ([SEMSC1]; sw; [SEMSC1]) |
                   ([SC1 | SEMSC1]; po; [REL & SEMSC1]) |
                   ([ACQ & SEMSC1]; po; [SC1 | SEMSC1])
                 )*
let ithbsemsc01 = ( sdv |
                   ([SEMSC01]; sw; [SEMSC01]) |
                   ([SC0 | SC1 | SEMSC01]; po; [REL & SEMSC01]) |
                   ([ACQ & SEMSC01]; po; [SC0 | SC1 | SEMSC01])
                 )*

let hb = ithbsemsc0 | ithbsemsc1 | ithbsemsc01 | po // happens-before

// loc order, relates memory accesses to the same location
let avsg = [AVSG]
let avwg = ((avsg; (hb & ssg & avvisinc))?); [AVWG]
let avqf = ((avsg; (hb & ssg & avvisinc))? ; (avwg; (hb & swg & avvisinc))?); [AVQF]
let avsh = ((avsg; (hb & ssg & avvisinc))? ; (avwg; (hb & swg & avvisinc))?; (avqf; (hb & sqf & avvisinc))?); [AVSHADER]
let avdv = [AVDEVICE]

let vissg = [VISSG]
let viswg = [VISWG];        (((hb & ssg & avvisinc); vissg)?)
let visqf = [VISQF];        (((hb & ssg & avvisinc) ; viswg)?; ((hb & ssg & avvisinc); vissg)?)
let vissh = [VISSHADER];    (((hb & ssg & avvisinc) ; visqf)?; ((hb & swg & avvisinc); viswg)?; ((hb & sqf & avvisinc); vissg)?)
let visdv = [VISDEVICE]

let locord = loc &
             (  (hb & int & vloc) |
                ([R \ PRIV]; hb; [R | W \ PRIV]) | // RaR, WaR (non-private)
                ([R]; sdv^-1; [R | W]) | // RaR, WaR (any)
                (vloc & ([W \ PRIV]; (po? & avvisinc); avsg; (hb & ssg);                         [W \ PRIV])) |                                 // WaW (via subgroup instance domain)
                (vloc & ([W \ PRIV]; (po? & avvisinc); avsg; (hb & ssg); vissg; (po?; avvisinc); [R \ PRIV]; (po? & avvisinc); [R \ PRIV])) |   // RaW (via subgroup instance domain)
                (vloc & ([W \ PRIV]; (po? & avvisinc); avwg; (hb & swg);                         [W \ PRIV])) |                                 // WaW (via subgroup instance domain)
                (vloc & ([W \ PRIV]; (po? & avvisinc); avwg; (hb & swg); viswg; (po?; avvisinc); [R \ PRIV]; (po? & avvisinc); [R \ PRIV])) |   // RaW (via workgroup instance domain)
                (vloc & ([W \ PRIV]; (po? & avvisinc); avqf; (hb & sqf);                         [W \ PRIV])) |                                 // WaW (via queue family instance domain)
                (vloc & ([W \ PRIV]; (po? & avvisinc); avqf; (hb & sqf); visqf; (po?; avvisinc); [R \ PRIV]; (po? & avvisinc); [R \ PRIV])) |   // RaW (via queue family instance domain)
                (vloc & ([W \ PRIV]; (po? & avvisinc); avsh; (hb);                               [W \ PRIV])) |                                 // WaW (via shader domain)
                (vloc & ([W \ PRIV]; (po? & avvisinc); avsh; (hb);       vissh; (po?; avvisinc); [R \ PRIV]; (po? & avvisinc); [R \ PRIV])) |   // RaW (via shader domain)
                (       ([W];        (hb & avvisinc);  avdv; (hb);                               [W])) |                                        // WaW (via device domain)
                (       ([W];        (hb & avvisinc);  avdv; (hb);       visdv; (hb & avvisinc); [R]; (po? & avvisinc); [R \ PRIV]))            // RaW (via device domain)
             )
let w-locord = [W]; locord
let visto = (w-locord \ (w-locord; w-locord)); [R] // visible to = location ordered W->R with no intervening write (W->W->R)
(*******************)



(***********************)
(* Memory Model Axioms *)
(***********************)
// consistency: locord, rf, fr, asmo must not form cycles
acyclic (locord | rf | fr | asmo) as consistency-cycle
// consistency: non-atomic cannot read-from a value that is shadowed by another write
empty (rf; ([R \ ATOM])) & (([W]; locord); ([W]; locord)+) as consistency-rf

let race-pair = W * W | W * R | R * W
empty loc & (race-pair \ mutordatom \ id \ (locord | locord^-1)) as dr

let read-write = (R \ W) | (W \ R) // TODO: check (X.R-X.W)
empty (((locord | locord^-1) | mutordatom \ [read-write]) \ (loc \ id \ [read-write])) as locord-complete