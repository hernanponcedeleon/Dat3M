SPIRV

(* Tags from spirv.als *)
// NONPRIV, PRIV : non-private (participates in inter-thread ordering) vs private
// SCOPESG, SCOPEWG, SCOPEQF, SCOPEDEV: subgroup/workgroup/queuefamily/device scopes

(* Terms from spirv.als no need for implementation *)
// stor : set to relation, (s,s) for all s in E, lift a set to a relation (the [_] operator in Herd)
// imm-r = r - r;r      ????? or r - (r;r+)
// twoplus-r = r;r      ????? or (r;r+)
// rai-r = r | r^-1
// sthd = int
// immpo = po - po;po
// rc[r] = r?

// ssg, swg, sqf, ssw = sr@ subgroup, workgroup, queuefamily, system
// inscope = sr

// pgmsloc = loc
// pgmsref == direct-alias
// sloc = virtual-loc
// sref = alias

//???????????
// chains = [_] or _*_ ?
// asmo = strong operation(with scope) ?????
// scbarinst: same control barrier dynamic instance

(*******************)
(*  Auxiliaries *)
(*******************)
let asmo = [ATOM & W]; mutordatom; [ATOM & W] // should be rai[asmo] = ((A&W) -> (A&W)) & mutordatom
(*******************)
let ithbsemsc0 = ( ssw |
                   ([SEMSC0]; sw; [SEMSC0]) |
                   ([SC0 | SEMSC0]; po; [REL & SEMSC0]) |
                   ([ACQ & SEMSC0]; po; [SC0 | SEMSC0])
                 )*
let ithbsemsc1 = ( ssw |
                   ([SEMSC1]; sw; [SEMSC1]) |
                   ([SC1 | SEMSC1]; po; [REL & SEMSC1]) |
                   ([ACQ & SEMSC1]; po; [SC1 | SEMSC1])
                 )*
let ithbsemsc01 = ( ssw |
                   ([SEMSC01]; sw; [SEMSC01]) |
                   ([SC0 | SC1 | SEMSC01]; po; [REL & SEMSC01]) |
                   ([ACQ & SEMSC01]; po; [SC0 | SC1 | SEMSC01])
                 )*

let hb = ithbsemsc0 | ithbsemsc1 | ithbsemsc01 | po // happens-before
(*******************)
let mutordatom = [ATOM]; ((sloc & sref & sr) \ id); [ATOM] // mutually ordered atomics (same loc, inscope)
let avvisinc = (((SC0 | SC1) * (AVDEVICE | VISDEVICE)) | ((AVDEVICE | VISDEVICE) * (SC0 | SC1)) |
               (SC0 * ((SEMAV | SEMVIS) & SEMSC0)) | (((SEMAV | SEMVIS) & SEMSC0) * SC0) |
               (SC1 * ((SEMAV | SEMVIS) & SEMSC0)) | (((SEMAV | SEMVIS) & SEMSC0) * SC1)) \ id |
               ([AV | VIS]; (sref & sloc)) | ((sref & sloc); [AV | VIS])


(* complex relations to be implemented *)
let asvg = [AVSG]
let avwg = (chains & (avsg; (hb & ssg & avvisinc))?); [AVWG]
let avqf = (chains & (avsg; (hb & ssg & avvisinc))? ; (avwg; (hb & swg & avvisinc))?); [AVQF]
let avsh = (chains & (avsg; (hb & ssg & avvisinc))? ; (avwg; (hb & swg & avvisinc))?; (avqf; (hb & sqf & avvisinc))?); [AVSHADER]
let avdv = [AVDEVICE]

let vissg = [VISSG]
let viswg = [VISWG];        (chains & ((hb & ssg & avvisinc); vissg)?)
let visqf = [VISQF];        (chains & ((hb & ssg & avvisinc) ; viswg)?; ((hb & ssg & avvisinc); vissg)?)
let vissh = [VISSHADER];    (chains & ((hb & ssg & avvisinc) ; visqf)?; ((hb & swg & avvisinc); viswg)?; ((hb & sqf & avvisinc); vissg)?)
let visdv = [VISDEVICE]
// loc order, relates memory accesses to the same location
let locord = sloc &
             (  (hb & int & sref) |
                ([R \ PRIV]; hb; [R | W \ PRIV]) | // RaR, WaR (non-private)
                ([R]; ssw^-1; [R | W]) | // RaR, WaR (any)
                (sref & ([W \ PRIV]; (po? & avvisinc); asvg; (hb & ssg);                         [W \ PRIV])) |                                 // WaW (via subgroup instance domain)
                (sref & ([W \ PRIV]; (po? & avvisinc); asvg; (hb & ssg); vissg; (po?; avvisinc); [R \ PRIV]; (po? & avvisinc); [R \ PRIV])) |   // RaW (via subgroup instance domain)
                (sref & ([W \ PRIV]; (po? & avvisinc); avwg; (hb & swg);                         [W \ PRIV])) |                                 // WaW (via subgroup instance domain)
                (sref & ([W \ PRIV]; (po? & avvisinc); avwg; (hb & swg); viswg; (po?; avvisinc); [R \ PRIV]; (po? & avvisinc); [R \ PRIV])) |   // RaW (via workgroup instance domain)
                (sref & ([W \ PRIV]; (po? & avvisinc); avqf; (hb & sqf);                         [W \ PRIV])) |                                 // WaW (via queue family instance domain)
                (sref & ([W \ PRIV]; (po? & avvisinc); avqf; (hb & sqf); visqf; (po?; avvisinc); [R \ PRIV]; (po? & avvisinc); [R \ PRIV])) |   // RaW (via queue family instance domain)
                (sref & ([W \ PRIV]; (po? & avvisinc); avsh; (hb);                               [W \ PRIV])) |                                 // WaW (via shader domain)
                (sref & ([W \ PRIV]; (po? & avvisinc); avsh; (hb);       vissh; (po?; avvisinc); [R \ PRIV]; (po? & avvisinc); [R \ PRIV])) |   // RaW (via shader domain)
                (       ([W];        (hb & avvisinc);  avdv; (hb);                               [W])) |                                        // WaW (via device domain)
                (       ([W];        (hb & avvisinc);  avdv; (hb);       visdv; (hb & avvisinc); [R]; (po? & avvisinc); [R \ PRIV]))            // RaW (via device domain)
             )



let posctosem = [SC0]; po; [SEMSC0] | [SC1]; po; [SEMSC1]
let posemtosc = [SEMSC0]; po; [SC0] | [SEMSC1]; po; [SC1]

let rs = [REL & ATOM]; ((asmo \ (asmo; asmo)); [R & W])*
let hypors = [W & ATOM]; ((asmo \ (asmo; asmo)); [R & W])*
// synchronizes-with is similar to C++, with an additional case for fence->cbar->cbar->fence
let sw = sr & (
    ([REL & ATOM]; rs; (rf & mutordatom); [ACQ & ATOM]) |                                               // atomic->atomic
    ([REL & F]; posemtosc; [ATOM & W]; hypors; (rf & mutordatom); [ACQ & ATOM]) |                       // fence->atomic
    ([REL & ATOM]; rs; (rf & mutordatom); [ATOM & R]; posctosem; [ACQ & F]) |                           // atomic->fence
    ([REL & F]; posemtosc; [ATOM & W]; hypors; (rf & mutordatom); [ATOM & R]; posctosem; [ACQ & F]) |   // fence->fence
    [REL & F]; po?; [CBAR]; (scbarinst & sr \ id); [CBAR]; po?; [ACQ & F]                               // fence->cbar->cbar->fence,
    // (stor[CBAR]) terms are redundant because scbarinst is an equivalence relation on scbarinst, but they make the sequence of instructions more clear.
)

let w-locord = [W]; locord
let visto = (w-locord \ (w-locord; w-locord)); [R] // visible to = location ordered W->R with no intervening write (W->W->R)


(***********************)
(* Memory Model Axioms *)
(***********************)
// consistency: locord, rf, fr, asmo must not form cycles
acyclic (locord | rf | fr | asmo) as consistency-cycle
// consistency: non-atomic cannot read-from a value that is shadowed by another write
empty (rf; ([R \ ATOM])) & (twoplus & ([W]; locord)) as consistency-rf

let race-pair = W * W | W * R | R * W
empty sloc & (race-pair \ mutordatom \ id \ (locord | locord^-1)) as dr

let read-write = R \ W | W \ R // TODO: check (X.R-X.W)
empty (((locord | locord^-1) | mutordatom \ read-write) \ (sloc \ id \ read-write)) as locord-complete