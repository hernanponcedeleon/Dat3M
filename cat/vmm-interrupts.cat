let ih = po^-1;([INTERRUPT_HANDLER];(po \ (po;[THREAD_CREATE];po));[THREAD_CREATE];rf;[THREAD_START]);po
let ext = ext & ((~IW) * M)
let int = int | (IW * M)
let rfe = (rf & ext) \ (ih^-1* ; ih*) 
let coe = (co & ext) \ (ih^-1* ; ih*)
let fre = (fr & ext) \ (ih^-1* ; ih*)
let rfi = rf & (int | (ih^-1* ; ih*))
let coi = co & (int | (ih^-1* ; ih*))
let fri = fr & (int | (ih^-1* ; ih*))
let eco = rf | co;(rf?) | fr;(rf?)

let Marked = RLX | ACQ | REL | SC
let Plain = ~Marked
let Acq = ACQ | (SC & R)
let Rel = REL | (SC & W)

(* Interrupt handling *)
let barrier = po?; [cb | Marked | F | ENABLE_INTERRUPT | DISABLE_INTERRUPT]; po? | [HARMLESS_RACY]
let nint = (po \ (po; [ENABLE_INTERRUPT] ; po?))^-1  ; [DISABLE_INTERRUPT] ; (po \ (po; [ENABLE_INTERRUPT] ; po?))
let ihb = ((nint | barrier) ; (eco &  ih+) ; int) | (int ; (eco &  ih+^-1) ; (nint | barrier))
let po = po | ihb+
let ctrl = ctrl ; ihb*

(** Atomicity **)
empty rmw & (fre;coe)

(** SC per location **)
acyclic co | rf | fr | po-loc

(** Ordering **)
let dep = (data;rfi | addr | ctrl)*;(ctrl | addr | data)

(* Plain writes can be elided and therefore are generally not ordered by things that order writes *)
let bob = [Acq];po | po;[Rel] | [SC];po;[SC] | po;[SC & F];po | [R];po;[Acq & F];po | po;[Rel & F];po;[W & Marked]
let ppo = bob | [Marked];(dep | coi | fri);[W & Marked]

(* 
   If there is no w-race, plain writes are slightly better-behaved: if they are read-from, then either 
    1) they exist and provide ordering, or 
    2) an older store with the same value exists and that store is also a candidate for the read, in which case the ordering provided in this graph is ignored in the graph in which the older store is observed
   
   However, the plain writes  may not exist in the form supposed by dependencies etc.
   This is especially true for data dependencies, which may be speculatively elided.
   Only ctrl and addr dependencies are not elided, because the compiler is not allowed to speculatively modify memory regions (which might be protected by a lock owned by another thread).
*)
let WRF-ppo = po;[Rel & F];po;[W & Plain] | [Marked];(ctrl | addr);[W & Plain]

let hb = ppo | WRF-ppo | rfe | fre | coe
acyclic hb

(* Interrupt Axioms *)
(* ihb axiom *)
acyclic ihb

let full-hb = hb

let would-ppo-up =
	Acq * M 
  | [domain([R] ; (po & nint) ; [Acq & F])] ; (M * M) 
  | (R * M) ; [range([Acq & F] ; po)] 
  | M * Rel 
  | [domain((po & nint) ; [Rel & F])] ; (M * (W & Marked)) 
  | (M * M) ; [range([Rel & F] ; po ; [W & Marked])]
  | SC * SC 
  | [domain((po & nint) ; [SC & F])] ; (M * M) 
  | (M * M) ; [range([SC & F] ; po)]
  | [domain(ctrl)] ; (M * W)
  | coi 
  | fri

let would-ppo-down =
	Acq * M 
  | [domain([R] ; po ; [Acq & F])] ; (M * M) 
  | (R * M) ; [range([Acq & F] ; (po & nint))] 
  | M * Rel 
  | [domain(po ; [Rel & F])] ; (M * (W & Marked)) 
  | (M * M) ; [range([Rel & F] ; (po & nint) ; [W & Marked])]
  | SC * SC 
  | [domain(po ; [SC & F])] ; (M * M) 
  | (M * M) ; [range([SC & F] ; (po & nint))]
  | [domain(ctrl)] ; (M * W)
  | coi 
  | fri

let hbi = full-hb* & int

let order-up   = (barrier | nint) ; (full-hb+ & ih+    & (hbi ; would-ppo-down ; hbi)^-1) ;       int
let order-down =       int        ; (full-hb+ & ih+^-1 & (hbi ; would-ppo-up   ; hbi)^-1) ; (barrier | nint)
  
(* F axiom *)
irreflexive order-up ; order-down

(** Data Races **)

let w-race-fix = ([Marked] | ppo);hb+;([Marked] | ppo)

let w-race = coe \ w-race-fix
let w-racy = [domain(w-race)] | [range(w-race)]
flag ~empty w-racy as w-data-race

let r-race-fix = w-race-fix | ([Marked] | ppo);hb+; WRF-ppo

let r-race = (fre | rfe) \ r-race-fix
let r-racy = [domain(r-race)] | [range(r-race)]
let obs-dep = (data;rfi)*;(ctrl | addr | data;rfe)
flag ~empty [domain(obs-dep)] & r-racy as r-data-race

(** Interrupt Data Races **)

let i-race-fix = ihb+ | order-up | order-down
let i-race = (eco & (ih+ | ih+^-1)) \ i-race-fix
flag ~empty i-race as i-data-race

(** Interrupt handlers disable **)

empty ([domain(ihb)] ; nint ; (id \ [domain(po \ nint)])) as ih-dis
