RC11

(*
 * Repaired C11 codel, following
 * "Repairing Sequential Consistency in C/C++11" in PLDI 2017  , by
 * Ori Lahav, Viktor Vafeiadis, Jeehoon Kang, Chung-Kil Hur, and Derek Dreyer
 * Cat coding by Sicon Colin.
 *)

(* Define co (and fr) *)
include "cos.cat"

// This is needed for herd which can create a single event for rmw instructions
let myrmw = [RMW] | rmw

let eco = (rf | co | fr)+
let rs = [W]; (po & loc)?; [W & (RLX | REL | ACQ_REL | ACQ | SC)]; (rf; myrmw)*
let sw = [(REL | ACQ_REL | SC)]; ([F]; po)?; rs; rf; [R & (RLX | REL | ACQ | ACQ_REL | SC)]; (po; [F])?; [(ACQ | ACQ_REL | SC)]
let hb = (po | sw)+

let pol = po \ loc
let hbl = hb & loc
let scb = po | pol; hb; pol | hbl | co | fr
let pscb = ([SC] | [F & SC]; hb?); scb; ([SC] | hb? ; [F & SC])
let pscf = [F & SC]; (hb | hb; eco; hb); [F & SC]
let psc = pscb | pscf

irreflexive hb; eco? as coherence1
irreflexive (myrmw; eco) as coherencermw
empty (myrmw & (fr; co)) as atomicity
acyclic psc as SC
acyclic (po | rf) as no-thin-air

(* data_races *)
// We treat initial events as non-atomic thus we need to explicit remove them
let conflict = ext & ((((W * _) | (_ * W)) & loc) \ ((IW * _) | (_ * IW)))
let race = conflict \ (A * A) \ hb \ (hb^-1) 

flag ~empty race as racy

(*
 * Heap memory safety.
 * Base relations:
 * allocptr - relates (ALLOC | FREE) -> (FREE) when both events use the same pointer
 * allocmem - relates (ALLOC) -> (M) when the second event accesses the memory allocated by the first event
 *)
(*
flag ~empty (((ALLOC * FREE) & allocptr) \ hb) as alloc-race
flag ~empty (((FREE * FREE) \ id) & allocptr) as double-free
flag ~empty ([FREE] \ [range(allocptr & (ALLOC * FREE))]) as free-without-alloc
flag ~empty (allocmem \ hb) as use-before-alloc
flag ~empty ((allocmem^-1 ; (allocptr & (ALLOC * FREE))) \ hb) as use-after-free
*)

// TODO: Non-monotonic! (see ThreadCreation class)
// flag ~empty ([ALLOC] \ [domain(allocptr)]) as alloc-without-free