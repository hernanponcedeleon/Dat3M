PTX

(*******************)
(*  Auxiliaries *)
(*******************)
(* Events *)
let strong-write = W & (RLX | REL | IW)
let strong-read = R & (RLX | ACQ)
let strong-m = strong-write | strong-read
let strong-operation = strong-write | strong-read | F

(* Relations *)
let sr-fence = ([strong-operation]; (sr & vloc); [F]) | ([F]; (sr & vloc); [strong-operation])
let po-fence = ([strong-operation]; (po & vloc); [F]) | ([F]; (po & vloc); [strong-operation])
let sr-m = ([strong-m]; (sr & vloc & loc); [strong-m])
let po-m = ([M]; (po & vloc & loc); [M])
let morally-strong = sr-fence | po-fence | sr-m | po-m

let fence-sc = [F & SC] ; sr; [F & SC]
let rec observation = (morally-strong & rf) | (observation; rmw; observation)
let release-pattern = ([W & REL]; po-loc?; [W]) | ([F & ACQ_REL]; po+; [W])
let acquire-pattern = ([R]; po-loc?; [R & ACQ]) | ([R]; po+; [F & ACQ_REL])
let sw = morally-strong & (release-pattern; observation+; acquire-pattern) | fence-sc
let cause-base = (po?; sw; po?)+ | po

(* Proxy-aware causality ordering *)
let generic-proxy = [GEN]; [GEN]
let surface-proxy = [SUR]; [SUR]
let texture-proxy = [TEX]; [TEX]
let constant-proxy = [CON]; [CON]
let same-proxy = generic-proxy | surface-proxy | texture-proxy | constant-proxy

let proxy-fence-m =  [F]; (same-proxy ); [M]
let proxy-m-fence =  [M]; (same-proxy ); [F]

let no-alias-fence = [GEN]; (vloc & cause-base); [GEN]
let no-proxy-fence = vloc & cause-base & same-proxy
let proxy-src-fence = (cause-base & proxy-m-fence); (cause-base & vloc); [GEN]
let proxy-dst-fence = [GEN]; (cause-base & vloc); (cause-base & proxy-fence-m)
let proxy-src-dst-fence = (cause-base & proxy-m-fence); (cause-base & vloc); (cause-base & proxy-fence-m)
let proxy-alias-fence = loc & ([GEN]; (cause-base; [F & ALIAS]; cause-base); [GEN])
let proxy-src-alias-fence = loc & ((cause-base & proxy-m-fence); (cause-base; [F & ALIAS]; cause-base); [GEN])
let proxy-dst-alias-fence = loc & ([GEN]; (cause-base; [F & ALIAS]; cause-base); (cause-base & proxy-fence-m))
let proxy-src-dst-alias-fence = loc & ((cause-base & proxy-m-fence); (cause-base; [F & ALIAS]; cause-base); (cause-base & proxy-fence-m))

let cause-proxy = no-alias-fence | no-proxy-fence | proxy-src-fence | proxy-dst-fence | proxy-src-dst-fence | proxy-alias-fence | proxy-src-alias-fence | proxy-dst-alias-fence | proxy-src-dst-alias-fence
let cause = cause-proxy | (observation; cause-proxy)

(******************************)
(* PTX Memory Model Axioms *)
(******************************)

(* Axiom 1 Coherence *)
let cause-write = [W]; (cause & loc); [W]
empty (cause-write \ co) as axiom-Coherence

(* Axiom 2 FenceSC *)
irreflexive (fence-sc ; cause) as axiom-FenceSC

(* Axiom 3 Atomicity *)
empty (((morally-strong & fr); (morally-strong & co)) & rmw) as axiom-Atomicity

(* Axiom 4 No-Thin-Air *)
let dep = addr | data | ctrl
acyclic (rf | dep) as axiom-NoThinAir

(* Axiom 5 SC-per-Location *)
acyclic ((morally-strong & (rf | co | fr)) | po-loc) as axiom-ScPerLocation

(* Axiom 6 Causality *)
irreflexive ((rf | fr ); cause) as axiom-Causality