let po-until(set) = po \ (po;[set];po)

(* Basic interrupt relations *)
let IHSpawn = [range([INTERRUPT_HANDLER];po-until(THREAD_CREATE))]
let ih = int;(IHSpawn;rf;int)+  // (...)+ to handle nested IHs

(* Interrupt points *)
let beforeIP = (new() & id)
// If it contains DISABLE_INTERRUPT it must contain the whole region up to next ENABLE_INTERRUPT
let beforeIP = beforeIP | [range((beforeIP & [DISABLE_INTERRUPT]);po-until(ENABLE_INTERRUPT))]
let afterIP = id \ beforeIP

(* Extend po/int/ext based on IP *)
let int = int | ih | ih^-1 | (IW * M)
let ext = ext \ int
let po = po | beforeIP;ih | ih^-1;afterIP
let ctrl = ctrl ; po*

let po-loc = po & loc
let rfe = rf & ext
let coe = co & ext
let fre = fr & ext
let rfi = rf & int
let coi = co & int
let fri = fr & int

// NOTE: beforeIP must be prefix-closed under the barrier ordering of the WMM
// Since this depends on the WMM, we do not define it here and instead rely on the WMM adding the axiom
// empty ([domain(barrier;beforeIP)] \ beforeIP)
// This can be achieved by include "interrupts-axioms.cat" inside the wmm