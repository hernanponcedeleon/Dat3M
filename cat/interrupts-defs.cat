let po-until(set) = po \ (po;[set];po)

(* Basic interrupt relations *)
let IHCreate = [range([INTERRUPT_HANDLER];po-until(THREAD_CREATE))]
let create2Ih = IHCreate;rf
let IHStart = [range(create2Ih)]
let it2ih = int;(create2Ih;int)+  // (...)+ to handle nested IHs

(* Guess a total execution order on the IHs for each thread (in case there are multiple) *)
let ihOrderPre = (new() & (IHCreate;int;IHCreate)) \ id
empty (IHCreate;int;IHCreate) \ (ihOrderPre | ihOrderPre^-1 | id)
acyclic ihOrderPre
let ihOrder = IHStart;rf^-1;ihOrderPre;rf;IHStart

(* Define interrupt points *)
let beforeIPs = (new() & (int;create2Ih)) | create2Ih
// IPs cannot occur when interrupts are disabled.
let beforeIPs = beforeIPs | ([DISABLE_INTERRUPT];po-until(ENABLE_INTERRUPT))^-1;beforeIPs
// IPs respect dependencies and ihOrder
let beforeIPs = (addr | ctrl | data | po-loc)?;beforeIPs;ihOrder?

let afterIPs = ((int;create2Ih) \ beforeIPs)^-1

// Extend beforeIPs/afterIPs to include all events of IH and even nested IHs
let beforeIPExt = beforeIPs;(it2ih | po?)
let afterIPExt = (it2ih | po?)^-1;afterIPs
let ihOrderExt = int;ihOrder;(it2ih | po?)

(* Extend po/int/ext based on IPs *)
let po_orig = po

let poReorder = beforeIPs;afterIPs
let poExt = beforeIPExt | afterIPExt | ihOrderExt
let po = (po \ poReorder^-1) | poReorder | poExt
let int = int | (it2ih^-1)?;it2ih | (IW * M)
let ext = ext \ int

let ctrl = ctrl ; po*

let po-loc = po & loc
let rfe = rf & ext
let coe = co & ext
let fre = fr & ext
let rfi = rf & int
let coi = co & int
let fri = fr & int

(* Events after non-terminating IH are never really executed: restrict their communication *)
let non-exec = [range([NONTERM];afterIPExt)]
let exec = id \ non-exec
empty (non-exec;(rf | co);exec)

// NOTE: beforeIPs must be prefix-closed under the barrier ordering of the WMM
// Since this depends on the WMM, we do not define it here and instead rely on the WMM adding the axiom
// empty ((barrier;beforeIPs) \ beforeIPs)
// This can be achieved by include "interrupts-axioms.cat" inside the WMM