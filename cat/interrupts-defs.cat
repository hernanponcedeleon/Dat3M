let po-until(set) = po \ (po;[set];po)

(* Basic interrupt relations *)
let IHSpawn = [range([INTERRUPT_HANDLER];po-until(THREAD_CREATE))]
let ih = int;(IHSpawn;rf;int)+  // (...)+ to handle nested IHs

(* Interrupt points *)
let beforeIP = (new() & [domain(ih)])
// If it contains DISABLE_INTERRUPT it must contain the whole region up to next ENABLE_INTERRUPT
let beforeIP = beforeIP | [range((beforeIP & [DISABLE_INTERRUPT]);po-until(ENABLE_INTERRUPT))]
let afterIP = [domain(ih)] \ beforeIP

(* Extend po/int/ext based on IP *)
let int = int | ih | ih^-1 | (IW * M)
let ext = ext \ int
let po = po | beforeIP;ih | ih^-1;afterIP
// NOTE: Restricting po to "po \ (afterIP ; _*_ ; beforeIP)" does not work out-of-the-box.
// We would need to make the original po available and let the WMM use that one to define barrier orderings
let ctrl = ctrl ; po*

let po-loc = po & loc
let rfe = rf & ext
let coe = co & ext
let fre = fr & ext
let rfi = rf & int
let coi = co & int
let fri = fr & int

(* If IH fails to terminate, some events in the execution are not actually executed: restrict their communication *)
let non-exec = [range([NONTERM];ih^-1;afterIP)]
let exec = id \ non-exec
empty (non-exec;(rf | co);exec)

// NOTE: beforeIP must be prefix-closed under the barrier ordering of the WMM
// Since this depends on the WMM, we do not define it here and instead rely on the WMM adding the axiom
// empty ([domain(barrier;beforeIP)] \ beforeIP)
// This can be achieved by include "interrupts-axioms.cat" inside the wmm